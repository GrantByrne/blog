<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Grant's Blog</title><link>/</link><description>Recent content on Grant's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Grant Byrne 2021</copyright><lastBuildDate>Tue, 04 May 2021 22:05:27 -0400</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Setting Window Size With Caliburn Micro</title><link>/posts/setting-window-size-with-caliburn-micro/</link><pubDate>Tue, 04 May 2021 22:05:27 -0400</pubDate><guid>/posts/setting-window-size-with-caliburn-micro/</guid><description>
This is something that has actually bugged me for a while. Once I figured it out, it annoyed me that I didn&amp;rsquo;t figure it out sooner.
When displaying a window in Caliburn.Micro, you can set attributes about the Window object when calling it.
So, let&amp;rsquo;s say you want to set the height and width on the window to 600 x 300:
First, you would start with something like this:
public class ShellViewModel : PropertyChangedBase, IShell { private readonly IWindowManager windowManager; public ShellViewModel() { this.</description></item><item><title>Wiring Up Fluent Validation With WPF</title><link>/posts/wiring-up-fluent-validation-with-wpf/</link><pubDate>Mon, 03 May 2021 22:30:07 -0400</pubDate><guid>/posts/wiring-up-fluent-validation-with-wpf/</guid><description>
Update
I originally wrote this proof of concept about 7 years ago early in my time with WPF. I published it on an earlier iteration of my blog via Github Gist and Wordpress (You can find the gist here). After which point I pretty much forgot out it.
I recently came across the Gist and found that it has helped out a surprising number of people. So, it makes sense to me to pull this in to a blog and annotate it a bit better.</description></item><item><title>Getting Started With Hangfire</title><link>/posts/getting-started-with-hangfire/</link><pubDate>Sun, 02 May 2021 22:00:44 -0400</pubDate><guid>/posts/getting-started-with-hangfire/</guid><description>
Putting together this guide for testing out hangfire to fill in some of the gaps I found through creating a greenfield hangfire application.
Setting up a database to test with Since I don&amp;rsquo;t have a SQL Server running that I can just attach to. I&amp;rsquo;ll have to run through the initial set up of SQL Express Edition
Navigate to the website: https://www.microsoft.com/en-us/sql-server/sql-server-downloads Under the &amp;ldquo;Express&amp;rdquo; item at the bottom of the fold, hit the button &amp;ldquo;Download Now &amp;gt;&amp;rdquo; Run the installer Select &amp;ldquo;Basic&amp;rdquo; option Hit the &amp;ldquo;Accept&amp;rdquo; button without reading anything because I actually want to get some work done.</description></item><item><title>Activator.CreateInstance Alternatives with Benchmarks</title><link>/posts/activatorcreateinstancealternativetesting/</link><pubDate>Fri, 24 Aug 2018 15:52:48 -0400</pubDate><guid>/posts/activatorcreateinstancealternativetesting/</guid><description>
.NET provides multiple ways of generating objects at runtime. Each of these options offer their own trades offs in terms of performance. I will demonstrate that not only are there great performance gains to be had over Activator.CreateInstance(&amp;hellip;), but I will also show that there are nuances to how you set up these classes that can dramatically effect performance.
Why is this important? While there may be more applications, two examples that I can think of that rely on generating objects at runtime are game development frameworks and IOC (inversion of control) containers.</description></item><item><title>Setting up Autofac with Caliburn Micro v3.2.0 and Autofac v4.8.1</title><link>/posts/settingupautofacwithcaliburnmicro/</link><pubDate>Wed, 15 Aug 2018 22:40:27 -0400</pubDate><guid>/posts/settingupautofacwithcaliburnmicro/</guid><description>
I find myself frequently setting up new projects with Caliburn Micro; however, It isnâ€™t always easy to remember the code to integrate Autofac with the bootstrapper. So, here is the template that I use when creating a new application.
public class ClientBootstrapper : BootstrapperBase { private static IContainer Container; public ClientBootstrapper() { this.Initialize(); } protected override void Configure() { var builder = new ContainerBuilder(); builder.RegisterType&amp;lt;WindowManager&amp;gt;() .AsImplementedInterfaces() .SingleInstance(); builder.RegisterType&amp;lt;EventAggregator&amp;gt;() .AsImplementedInterfaces() .SingleInstance(); Container = builder.</description></item><item><title>First Post</title><link>/posts/first/</link><pubDate>Wed, 15 Aug 2018 22:16:38 -0400</pubDate><guid>/posts/first/</guid><description>
Hello World!
After multiple attempts in the past I&amp;rsquo;m looking to start blogging again.
In this iteration, I&amp;rsquo;m using an Amazon S3 bucket serving up a static site that is generated with Hugo. So far I&amp;rsquo;m pretty happy with the results.
In future iterations of the site, I&amp;rsquo;m planning to:
Add tagging support to the posts Add the google analytics tag Make some adjustments to the theme to make it even more lightweight Add a landing page so this website is more than just a blog Add references to the other sites where I spend my time: Github and Instagram.</description></item></channel></rss>