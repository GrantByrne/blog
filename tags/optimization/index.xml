<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>optimization on Grant's Blog</title><link>/tags/optimization/</link><description>Recent content in optimization on Grant's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Grant Byrne 2021</copyright><lastBuildDate>Fri, 24 Aug 2018 15:52:48 -0400</lastBuildDate><atom:link href="/tags/optimization/index.xml" rel="self" type="application/rss+xml"/><item><title>Activator.CreateInstance Alternatives with Benchmarks</title><link>/posts/activatorcreateinstancealternativetesting/</link><pubDate>Fri, 24 Aug 2018 15:52:48 -0400</pubDate><guid>/posts/activatorcreateinstancealternativetesting/</guid><description>
.NET provides multiple ways of generating objects at runtime. Each of these options offer their own trades offs in terms of performance. I will demonstrate that not only are there great performance gains to be had over Activator.CreateInstance(&amp;hellip;), but I will also show that there are nuances to how you set up these classes that can dramatically effect performance.
Why is this important? While there may be more applications, two examples that I can think of that rely on generating objects at runtime are game development frameworks and IOC (inversion of control) containers.</description></item></channel></rss>